--- mnemosyne/core/mnemosyne_core.py.orig2	2009-04-20 08:01:59.000000000 +1000
+++ mnemosyne/core/mnemosyne_core.py	2009-04-21 07:50:40.000000000 +1000
@@ -13,7 +13,6 @@
 logger = logging.getLogger("mnemosyne")
 
 
-
 ##############################################################################
 #
 # migrate_basedir
@@ -165,6 +164,7 @@
 ##############################################################################
 
 def initialise(basedir_ = None):
+    global gradefile, statfile
 
     import mnemosyne_log
 
@@ -183,6 +183,9 @@
     if not exists(basedir):
         os.mkdir(basedir)
 
+    gradefile = open(join(basedir, 'grades'), 'w')
+    statfile = open(join(basedir, 'stats'), 'w')
+
     if not exists(join(basedir, "history")):
         os.mkdir(join(basedir, "history"))
 
@@ -1109,6 +1112,7 @@
 def unload_database():
 
     global items, revision_queue, categories, category_by_name
+    global statfile, gradefile
         
     save_database(config["path"])
     
@@ -1119,6 +1123,9 @@
         
     categories = []
     category_by_name = {}
+
+    statfile.close()
+    gradefile.close()
     
     return True
 
@@ -3386,6 +3393,10 @@
 def process_answer(item, new_grade, dry_run=False):
 
     global revision_queue, items
+    global gradefile, statfile
+
+    if not dry_run:
+	gradefile.write("%s %d\n" % (item.id, new_grade));
 
     # When doing a dry run, make a copy to operate on. Note that this
     # leaves the original in items and the reference in the GUI intact.
@@ -3541,6 +3552,15 @@
                 scheduled_interval, actual_interval,
                 new_interval, noise, thinking_time)
 
+    if not dry_run: 
+	statfile.write(
+	    "%s: %01x,%04x,%04x,%04x,%04x,%04x,%04x,%08x,%08x,%01x\n" %
+	    (item.id,
+	     item.grade, int(item.easiness * 1000), item.acq_reps, item.ret_reps,
+	     item.lapses, item.acq_reps_since_lapse,
+	     item.ret_reps_since_lapse,
+	     item.last_rep, item.next_rep, item.unseen))
+
     return new_interval + noise
 
 
